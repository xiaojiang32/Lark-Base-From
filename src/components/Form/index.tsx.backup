import './style.scss';
import React, { useState, useEffect } from 'react';
import { DashboardState } from '@lark-base-open/js-sdk';
import { Toast, Tabs, TabPane, Button, Modal, Input, InputNumber, Select, Switch } from '@douyinfe/semi-ui';
import { useFormConfig, useFormValidation, useFormSubmit } from '../../hooks';
import { IFormConfig, IFormField, FieldType } from '../../types';
import TextField from './fields/TextField';
import OptionField from './fields/OptionField';
import SelectField from './fields/SelectField';
import MultiSelectField from './fields/MultiSelectField';
import DatePickerField from './fields/DatePickerField';
import TimePickerField from './fields/TimePickerField';
import DateTimePickerField from './fields/DateTimePickerField';
import SubmitButton from './fields/SubmitButton';
import ComponentLibrary from './config/ComponentLibrary';
import FieldConfigPanel from './config/FieldConfigPanel';
import SubmitConfigPanel from './config/SubmitConfigPanel';
import { generateId } from '../../utils';

function GlobalConfigPanel({ config, setConfig, saveConfig }: any) {
  return (
    <div className="global-config-panel">
      <div className="form">
        <div className="config-group">
          <div className="config-group-title">åŸºç¡€ä¿¡æ¯</div>
          <div className="config-section">
            <label>è¡¨å•å®½åº¦</label>
            <Select
              value={config.width}
              onChange={(value) => setConfig({ ...config, width: value })}
              optionList={[
                { value: 'narrow', label: 'çª?(300px)' },
                { value: 'standard', label: 'æ ‡å‡† (500px)' },
                { value: 'wide', label: 'å®?(700px)' },
                { value: 'full', label: 'å…¨å®½ (100%)' }
              ]}
            />
          </div>
          <div className="config-section">
            <label>è¡¨å•å¯¹é½</label>
            <Select
              value={config.align}
              onChange={(value) => setConfig({ ...config, align: value })}
              optionList={[
                { value: 'left', label: 'å·¦å¯¹é½? },
                { value: 'center', label: 'å±…ä¸­å¯¹é½' },
                { value: 'right', label: 'å³å¯¹é½? }
              ]}
            />
          </div>
          <div className="config-section">
            <label>å¸ƒå±€æ¨¡å¼</label>
            <Select
              value={config.layoutMode}
              onChange={(value) => setConfig({ ...config, layoutMode: value })}
              optionList={[
                { value: 'single', label: 'å•åˆ—å¸ƒå±€' },
                { value: 'double', label: 'ä¸¤åˆ—å¸ƒå±€' }
              ]}
            />
          </div>
          <div className="config-section">
            <label>å­—æ®µé—´è·</label>
            <InputNumber
              value={config.fieldSpacing}
              onChange={(value) => setConfig({ ...config, fieldSpacing: value || 4 })}
              min={1}
              max={16}
            />
          </div>
        </div>

        <div className="config-group">
          <div className="config-group-title">æ ·å¼</div>
          <div className="config-section">
            <div style={{ display: 'flex', alignItems: 'center' }}>
              <Switch
                checked={config.showShadow}
                onChange={(checked) => setConfig({ ...config, showShadow: checked })}
              />
              <span style={{ marginLeft: 8 }}>æ˜¾ç¤ºé˜´å½±</span>
            </div>
          </div>
          <div className="config-section">
            <label>åœ†è§’å¤§å°</label>
            <InputNumber
              value={config.borderRadius}
              onChange={(value) => setConfig({ ...config, borderRadius: value || 8 })}
              min={0}
              max={16}
            />
          </div>
        </div>

        <div className="config-group">
          <div className="config-group-title">æäº¤æŒ‰é’®</div>
          <div className="config-section">
            <label>æŒ‰é’®æ–‡æœ¬</label>
            <Input
              value={config.submitButton.text}
              onChange={(value) => setConfig({
                ...config,
                submitButton: { ...config.submitButton, text: value }
              })}
              maxLength={20}
            />
          </div>
          <div className="config-section">
            <label>æäº¤æˆåŠŸæç¤º</label>
            <Input
              value={config.submitButton.successMessage}
              onChange={(value) => setConfig({
                ...config,
                submitButton: { ...config.submitButton, successMessage: value }
              })}
              maxLength={50}
            />
          </div>
          <div className="config-section">
            <label>æäº¤åæ“ä½?/label>
            <Select
              value={config.submitButton.afterSubmit}
              onChange={(value) => setConfig({
                ...config,
                submitButton: { ...config.submitButton, afterSubmit: value }
              })}
              optionList={[
                { value: 'reset', label: 'é‡ç½®è¡¨å•' },
                { value: 'disable', label: 'ç¦ç”¨è¡¨å•' },
                { value: 'keep', label: 'ä¿æŒè¡¨å•' }
              ]}
            />
          </div>
        </div>

        <Button type="primary" theme="solid" onClick={saveConfig} style={{ width: '100%', marginTop: 20 }}>
          ä¿å­˜
        </Button>
      </div>
    </div>
  );
}

function getFieldTypeName(type: string): string {
  const typeMap: Record<string, string> = {
    text: 'è¾“å…¥æ¡?,

    option: 'é€‰é¡¹è¾“å…¥æ¡?,
    select: 'ä¸‹æ‹‰é€‰æ‹©',
    multiSelect: 'ä¸‹æ‹‰å¤šé€?,
    datePicker: 'æ—¥æœŸé€‰æ‹©å™?,
    timePicker: 'æ—¶é—´é€‰æ‹©å™?,
    dateTimePicker: 'æ—¥æœŸæ—¶é—´é€‰æ‹©å™?,
  };
  return typeMap[type] || type;
}

function classnames(obj: Record<string, boolean>): string {
  return Object.keys(obj)
    .filter(key => obj[key])
    .join(' ');
}

interface FormProps {
  bgColor: string;
}

export default function Form({ bgColor }: FormProps) {
  const { config, setConfig, mode, saveConfig } = useFormConfig();
  const { errors, isValid, validateFieldById, validateAll, clearErrors } = useFormValidation(config.fields);
  const { isSubmitting, submitResult, submitForm, registerHooks } = useFormSubmit(config);
  const [formData, setFormData] = useState<Record<string, any>>({});
  const [isFormDisabled, setIsFormDisabled] = useState(false);
  const [selectedField, setSelectedField] = useState<IFormField | null>(null);
  const [activeTab, setActiveTab] = useState<string>('global');
  const [deleteConfirmVisible, setDeleteConfirmVisible] = useState(false);
  const [fieldToDelete, setFieldToDelete] = useState<string>('');

  useEffect(() => {
    registerHooks({
      onMount: ({ form }) => {
        console.log('Form mounted:', form);
      },
      onChange: ({ id, value, form }) => {
        console.log(`Field ${id} changed:`, value);
      },
      onValidate: ({ errors }) => {
        console.log('Validation errors:', errors);
        return true;
      },
      onSubmit: ({ values }) => {
        console.log('Form submitted:', values);
        return true;
      },
      onError: ({ errors }) => {
        console.log('Submit errors:', errors);
      },
    });
  }, []);

  useEffect(() => {
    const initialFormData: Record<string, any> = {};
    config.fields.forEach(field => {
      if (field.type === 'text') {
        initialFormData[field.id] = (field as any).defaultValue || '';
      } else if (field.type === 'option') {
        const optionField = field as any;
        if (optionField.optionType === 'checkbox') {
          initialFormData[field.id] = optionField.options
            .filter((opt: any) => opt.defaultChecked)
            .map((opt: any) => opt.value || opt.label);
        } else {
          const defaultOption = optionField.options.find((opt: any) => opt.defaultChecked);
          initialFormData[field.id] = defaultOption ? (defaultOption.value || defaultOption.label) : '';
        }
      } else if (field.type === 'select') {
        initialFormData[field.id] = (field as any).defaultValue || '';
      } else if (field.type === 'multiSelect') {
        initialFormData[field.id] = (field as any).defaultValue || [];
      } else if (field.type === 'datePicker') {
        initialFormData[field.id] = (field as any).defaultValue || '';
      } else if (field.type === 'timePicker') {
        initialFormData[field.id] = (field as any).defaultValue || '';
      } else if (field.type === 'dateTimePicker') {
        initialFormData[field.id] = (field as any).defaultValue || '';
      } else if (field.type === 'collapseGroup') {
        const collapseField = field as any;
        if (collapseField.maxSelect !== 1) {
          initialFormData[field.id] = collapseField.options
            .filter((opt: any) => opt.defaultChecked)
            .map((opt: any) => opt.value || opt.label);
        } else {
          const defaultOption = collapseField.options.find((opt: any) => opt.defaultChecked);
          initialFormData[field.id] = defaultOption ? (defaultOption.value || defaultOption.label) : '';
        }
      }
    });
    setFormData(initialFormData);
  }, [config.fields]);

// ä¸´æ—¶è®¾ç½®ï¼šä»»ä½•çŠ¶æ€ä¸‹éƒ½æ˜¾ç¤ºé…ç½®é¢æ?
//const isConfig = true;
  // æ ¹æ®é£ä¹¦å¹³å°çš?mode çŠ¶æ€å†³å®šæ˜¯å¦æ˜¾ç¤ºé…ç½®é¢æ?
  // åˆ›å»ºçŠ¶æ€å’Œé…ç½®çŠ¶æ€æ˜¾ç¤ºé…ç½®é¢æ¿ï¼Œå±•ç¤ºçŠ¶æ€å’Œå…¨å±çŠ¶æ€ä¸æ˜¾ç¤º
  //const isConfig = mode === DashboardState.Config || mode === DashboardState.Create;

  // ä¸´æ—¶è®¾ç½®ï¼šä»»ä½•çŠ¶æ€ä¸‹éƒ½æ˜¾ç¤ºé…ç½®é¢æ?
  const isConfig = true;

  // æ£€æŸ¥å­—æ®µæ˜¯å¦åº”è¯¥æ˜¾ç¤ºï¼ˆåŸºäºçˆ¶çº§é€‰é¡¹çš„å…³è”å…³ç³»ï¼‰
  const isFieldVisible = (field: IFormField): boolean => {
    // å¦‚æœæ²¡æœ‰çˆ¶çº§å­—æ®µï¼Œåˆ™å§‹ç»ˆæ˜¾ç¤º
    if (!field.parentFieldId) {
      return true;
    }

    // è·å–çˆ¶çº§å­—æ®µçš„å€?
    const parentValue = formData[field.parentFieldId];

    // å¦‚æœçˆ¶çº§å­—æ®µæ²¡æœ‰å€¼ï¼Œåˆ™ä¸æ˜¾ç¤º
    if (!parentValue) {
      return false;
    }

    // æ£€æŸ¥çˆ¶çº§é€‰é¡¹çš„å€¼æ˜¯å¦åŒ¹é…?
    if (Array.isArray(parentValue)) {
      // å¤šé€‰æƒ…å†µï¼šåªè¦é€‰ä¸­äº†åŒ¹é…çš„é€‰é¡¹å°±æ˜¾ç¤?
      return parentValue.includes(field.parentOptionValue);
    } else {
      // å•é€‰æƒ…å†µï¼šå€¼åŒ¹é…æ‰æ˜¾ç¤º
      return parentValue === field.parentOptionValue;
    }
  };

  const handleFieldChange = (fieldId: string, value: any) => {
    setFormData(prev => ({
      ...prev,
      [fieldId]: value
    }));
    validateFieldById(fieldId, value);
  };

  const handleFieldBlur = (fieldId: string) => {
    validateFieldById(fieldId, formData[fieldId]);
  };

  const scrollToFirstError = () => {
    const firstErrorFieldId = Object.keys(errors).find(fieldId => errors[fieldId]);
    if (firstErrorFieldId) {
      const element = document.querySelector(`[data-field-id="${firstErrorFieldId}"]`);
      if (element) {
        element.scrollIntoView({ behavior: 'smooth', block: 'center' });
        const inputElement = element.querySelector('input, select, textarea');
        if (inputElement) {
          (inputElement as HTMLElement).focus();
        }
      }
    }
  };

  const handleAddField = (type: FieldType) => {
    const newField: IFormField = {
      id: generateId(type),
      type,
      name: 'æ–°å­—æ®?,
      required: false,
      order: config.fields.length,
      labelSpacing: 8,
    };

    switch (type) {
      case 'text':
        Object.assign(newField, {
          placeholder: 'è¯·è¾“å…?,
          maxLength: 200,
          inputType: 'none',
        });
        break;
      case 'option':
        Object.assign(newField, {
          optionType: 'radio',
          options: [
            { id: generateId('option'), label: 'é€‰é¡¹1', order: 0 },
            { id: generateId('option'), label: 'é€‰é¡¹2', order: 1 },
          ],
        });
        break;
      case 'select':
        Object.assign(newField, {
          placeholder: 'è¯·é€‰æ‹©',
          options: [
            { id: generateId('select'), label: 'é€‰é¡¹1', order: 0 },
            { id: generateId('select'), label: 'é€‰é¡¹2', order: 1 },
          ],
        });
        break;
      case 'multiSelect':
        Object.assign(newField, {
          placeholder: 'è¯·é€‰æ‹©',
          options: [
            { id: generateId('multiSelect'), label: 'é€‰é¡¹1', order: 0 },
            { id: generateId('multiSelect'), label: 'é€‰é¡¹2', order: 1 },
          ],
        });
        break;
      case 'datePicker':
        Object.assign(newField, {
          placeholder: 'è¯·é€‰æ‹©æ—¥æœŸ',
          dateFormat: 'YYYY-MM-DD',
        });
        break;
      case 'timePicker':
        Object.assign(newField, {
          placeholder: 'è¯·é€‰æ‹©æ—¶é—´',
          timeFormat: 'HH:mm',
          timeInterval: 30,
        });
        break;
      case 'dateTimePicker':
        Object.assign(newField, {
          placeholder: 'è¯·é€‰æ‹©æ—¥æœŸæ—¶é—´',
          dateFormat: 'YYYY-MM-DD',
          timeFormat: 'HH:mm',
          timeInterval: 30,
        });
        break;
      case 'collapseGroup' as FieldType:
        Object.assign(newField, {
          direction: 'down',
          maxSelect: 1,
          options: [
            { id: generateId('collapseGroup'), label: 'é€‰é¡¹1', order: 0 },
            { id: generateId('collapseGroup'), label: 'é€‰é¡¹2', order: 1 },
          ],
        });
        break;
    }

    setConfig({
      ...config,
      fields: [...config.fields, newField as any],
    });
    setSelectedField(newField);
    setActiveTab('config');
  };

  const handleUpdateField = (updatedField: IFormField & { _originalId?: string }) => {
    const { _originalId, ...fieldData } = updatedField;
    const targetId = _originalId || updatedField.id;
    
    setConfig({
      ...config,
      fields: config.fields.map(field =>
        field.id === targetId ? fieldData as IFormField : field
      ),
    });
    setSelectedField(fieldData as IFormField);
  };

  const handleDeleteField = (fieldId: string) => {
    setFieldToDelete(fieldId);
    setDeleteConfirmVisible(true);
  };

  const confirmDeleteField = () => {
    setConfig({
      ...config,
      fields: config.fields.filter(field => field.id !== fieldToDelete),
    });
    if (selectedField?.id === fieldToDelete) {
      setSelectedField(null);
    }
    setDeleteConfirmVisible(false);
    setFieldToDelete('');
  };

  const cancelDeleteField = () => {
    setDeleteConfirmVisible(false);
    setFieldToDelete('');
  };

  const handleFieldClick = (field: IFormField) => {
    setSelectedField(field);
    setActiveTab('config');
  };

  const handleSubmit = async () => {
    const isValid = validateAll(formData);
    if (!isValid) {
      Toast.error('è¯·æ£€æŸ¥è¡¨å•å¡«å†™æ˜¯å¦æ­£ç¡?);
      scrollToFirstError();
      return;
    }

    const result = await submitForm(formData);

    if (result?.success) {
      Toast.success(submitResult?.message || config.submitButton.successMessage);

      switch (config.submitButton.afterSubmit) {
        case 'reset':
          resetForm();
          break;
        case 'disable':
          setIsFormDisabled(true);
          break;
        case 'keep':
          break;
      }
    } else {
      Toast.error(submitResult?.message || 'æäº¤å¤±è´¥');
    }
  };

  const resetForm = () => {
    const initialFormData: Record<string, any> = {};
    config.fields.forEach(field => {
      if (field.type === 'text') {
        initialFormData[field.id] = (field as any).defaultValue || '';
      } else if (field.type === 'option') {
        const optionField = field as any;
        if (optionField.optionType === 'checkbox') {
          initialFormData[field.id] = optionField.options
            .filter((opt: any) => opt.defaultChecked)
            .map((opt: any) => opt.value || opt.label);
        } else {
          const defaultOption = optionField.options.find((opt: any) => opt.defaultChecked);
          initialFormData[field.id] = defaultOption ? (defaultOption.value || defaultOption.label) : '';
        }
      } else if (field.type === 'select') {
        initialFormData[field.id] = (field as any).defaultValue || '';
      } else if (field.type === 'multiSelect') {
        initialFormData[field.id] = (field as any).defaultValue || [];
      } else if (field.type === 'datePicker') {
        initialFormData[field.id] = (field as any).defaultValue || '';
      } else if (field.type === 'timePicker') {
        initialFormData[field.id] = (field as any).defaultValue || '';
      } else if (field.type === 'dateTimePicker') {
        initialFormData[field.id] = (field as any).defaultValue || '';
      } else if (field.type === 'collapseGroup') {
        const collapseField = field as any;
        if (collapseField.maxSelect !== 1) {
          initialFormData[field.id] = collapseField.options
            .filter((opt: any) => opt.defaultChecked)
            .map((opt: any) => opt.value || opt.label);
        } else {
          const defaultOption = collapseField.options.find((opt: any) => opt.defaultChecked);
          initialFormData[field.id] = defaultOption ? (defaultOption.value || defaultOption.label) : '';
        }
      }
    });
    setFormData(initialFormData);
    clearErrors();
    setIsFormDisabled(false);
  };

  const renderField = (field: IFormField) => {
    const value = formData[field.id];
    const error = errors[field.id];

    switch (field.type) {
      case 'text':
        return (
          <div key={field.id} data-field-id={field.id}>
            <TextField
              field={field as any}
              value={value || ''}
              onChange={(val) => handleFieldChange(field.id, val)}
              onBlur={() => handleFieldBlur(field.id)}
              error={error}
              disabled={isFormDisabled}
            />
          </div>
        );
      case 'option':
        return (
          <div key={field.id} data-field-id={field.id}>
            <OptionField
              field={field as any}
              value={value}
              onChange={(val) => handleFieldChange(field.id, val)}
              error={error}
              disabled={isFormDisabled}
            />
          </div>
        );
      case 'select':
        return (
          <div key={field.id} data-field-id={field.id}>
            <SelectField
              field={field as any}
              value={value || ''}
              onChange={(val) => handleFieldChange(field.id, val)}
              error={error}
              disabled={isFormDisabled}
            />
          </div>
        );
      case 'multiSelect':
        return (
          <div key={field.id} data-field-id={field.id}>
            <MultiSelectField
              field={field as any}
              value={value || []}
              onChange={(val) => handleFieldChange(field.id, val)}
              error={error}
              disabled={isFormDisabled}
            />
          </div>
        );
      case 'datePicker':
        return (
          <div key={field.id} data-field-id={field.id}>
            <DatePickerField
              field={field as any}
              value={value || ''}
              onChange={(val) => handleFieldChange(field.id, val)}
              error={error}
              disabled={isFormDisabled}
            />
          </div>
        );
      case 'timePicker':
        return (
          <div key={field.id} data-field-id={field.id}>
            <TimePickerField
              field={field as any}
              value={value || ''}
              onChange={(val) => handleFieldChange(field.id, val)}
              error={error}
              disabled={isFormDisabled}
            />
          </div>
        );
      case 'dateTimePicker':
        return (
          <div key={field.id} data-field-id={field.id}>
            <DateTimePickerField
              field={field as any}
              value={value || ''}
              onChange={(val) => handleFieldChange(field.id, val)}
              error={error}
              disabled={isFormDisabled}
            />
          </div>
        );
      case 'richText':
        return (
          <div key={field.id} data-field-id={field.id}>
            <RichTextField
              field={field as any}
              value={value || ''}
              onChange={(val) => handleFieldChange(field.id, val)}
              error={error}
              disabled={isFormDisabled}
            />
          </div>
        );
      default:
        return null;
    }
  };

  const getFormWidth = () => {
    switch (config.width) {
      case 'narrow':
        return '300px';
      case 'standard':
        return '500px';
      case 'wide':
        return '700px';
      case 'full':
        return '100%';
      default:
        return '500px';
    }
  };

  const getFormAlign = () => {
    switch (config.align) {
      case 'left':
        return 'flex-start';
      case 'center':
        return 'center';
      case 'right':
        return 'flex-end';
      default:
        return 'center';
    }
  };

  return (
    <main style={{ backgroundColor: bgColor }} className={classnames({ 'main-config': isConfig, 'main': true })}>
      <div className="content">
        <div
          className={`form-container ${config.layoutMode === 'double' ? 'form-container-double' : ''}`}
          style={{
            width: getFormWidth(),
            alignItems: getFormAlign(),
            padding: '16px',
            border: '1px solid var(--divider)',
            boxShadow: config.showShadow ? '0 2px 8px rgba(0, 0, 0, 0.1)' : 'none',
            borderRadius: `${config.borderRadius}px`,
            gap: `${config.fieldSpacing}px`,
            display: config.layoutMode === 'double' ? 'grid' : 'flex',
            gridTemplateColumns: config.layoutMode === 'double' ? '1fr 1fr' : 'auto',
            flexDirection: config.layoutMode === 'double' ? 'row' : 'column',
          }}
        >

          {config.description && <p className="form-description">{config.description}</p>}
          {config.fields.sort((a, b) => a.order - b.order).filter(isFieldVisible).map((field) => renderField(field))}
          <SubmitButton
            config={config.submitButton}
            onClick={handleSubmit}
            disabled={isFormDisabled}
            loading={isSubmitting}
          />
        </div>
      </div>

      {isConfig && (
        <div className="config-panel">
          <Tabs activeKey={activeTab} onChange={setActiveTab}>
            <TabPane tab="é…ç½®" itemKey="global">
              <GlobalConfigPanel config={config} setConfig={setConfig} saveConfig={saveConfig} />
            </TabPane>
            <TabPane tab="ç»„ä»¶" itemKey="library">
              <ComponentLibrary onAddField={handleAddField} />
            </TabPane>
            <TabPane tab="ç»„ä»¶é…ç½®" itemKey="config">
              <div className="fields-list">
                {config.fields.map((field) => (
                  <div
                    key={field.id}
                    className={`field-item ${selectedField?.id === field.id ? 'selected' : ''}`}
                    onClick={() => handleFieldClick(field)}
                  >
                    <span className="field-type">{getFieldTypeName(field.type)}</span>
                    <span className="field-name">{field.name}</span>
                    <Button
                      type="danger"
                      size="small"
                      onClick={(e) => {
                        e.stopPropagation();
                        handleDeleteField(field.id);
                      }}
                    >
                      åˆ é™¤
                    </Button>
                  </div>
                ))}
              </div>
              {selectedField && (
                <FieldConfigPanel
                  field={selectedField}
                  onUpdateField={handleUpdateField}
                  onDeleteField={handleDeleteField}
                  allFields={config.fields}
                />
              )}
            </TabPane>
            <TabPane tab="æ•°æ®æäº¤" itemKey="submit">
              <SubmitConfigPanel config={config} setConfig={setConfig} fields={config.fields} />
            </TabPane>
          </Tabs>
        </div>
      )}

      <Modal
        title="ç¡®è®¤åˆ é™¤"
        visible={deleteConfirmVisible}
        onOk={confirmDeleteField}
        onCancel={cancelDeleteField}
        okText="ç¡®å®š"
        cancelText="å–æ¶ˆ"
      >
        ç¡®å®šè¦åˆ é™¤è¿™ä¸ªå­—æ®µå—ï¼?
      </Modal>
    </main>
  );
}
